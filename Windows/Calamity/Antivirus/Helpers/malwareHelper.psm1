Import-Module ".\Helpers\registryHelper.psm1" -Force

function winLogonHelper { 
    Write-Host "--------------------------"
    Write-Host "Winlogon Helper DLL (HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon)"
    Write-Host "--------------------------"
    Write-Host ""

    $userInit = (GetRegistryKeyValue "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit")
    $Shell = (GetRegistryKeyValue "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell") 
    $Notify = (GetRegistryKeyValue "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify")

    if ($userInit -ne "C:\Windows\system32\userinit.exe,") {
        Write-Host "Userinit: " $userInit -ForegroundColor Red
    } else { Write-Host "Userinit: " $userInit }

    if ($Shell -ne "explorer.exe") {
        Write-Host "Shell: " $Shell -ForegroundColor Red
    } else { Write-Host "Shell: " $Shell }

    if ($null -ne $Notify) {
        Write-Host "Notify: " $Notify -ForegroundColor Red
    } else { Write-Host "Notify: " $Notify }
}

function FixUnquotedServicePaths { # Stolen from https://www.itsecguy.com/fixing_unquoted/
        $BaseKeys = "HKLM:\System\CurrentControlSet\Services",                                  #Services
                "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall",                #32bit Uninstalls
                "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall"     #64bit Uninstalls
    #Blacklist for keys to ignore
    $BlackList = $Null
    #Create an ArrayList to store results in
    $Values = New-Object System.Collections.ArrayList
    #Discovers all registry keys under the base keys
    $DiscKeys = Get-ChildItem -Recurse -Directory $BaseKeys -Exclude $BlackList -ErrorAction SilentlyContinue |
                Select-Object -ExpandProperty Name | %{($_.ToString().Split('\') | Select-Object -Skip 1) -join '\'}
    #Open the local registry
    $Registry = [Microsoft.Win32.RegistryKey]::OpenBaseKey('LocalMachine', 'Default')
    ForEach ($RegKey in $DiscKeys)
    {
        #Open each key with write permissions
        Try { $ParentKey = $Registry.OpenSubKey($RegKey, $True) }
        Catch { Write-Debug "Unable to open $RegKey" }
        #Test if registry key has values
        If ($ParentKey.ValueCount -gt 0)
        {
            $MatchedValues = $ParentKey.GetValueNames() | ?{ $_ -eq "ImagePath" -or $_ -eq "UninstallString" }
            ForEach ($Match in $MatchedValues)
            {
                #RegEx that matches values containing .exe with a space in the exe path and no double quote encapsulation
                $ValueRegEx = '(^(?!\u0022).*\s.*\.[Ee][Xx][Ee](?<!\u0022))(.*$)'
                $Value = $ParentKey.GetValue($Match)
                #Test if value matches RegEx
                If ($Value -match $ValueRegEx)
                {
                    $RegType = $ParentKey.GetValueKind($Match)
                    If ($RegType -eq "ExpandString")
                    {
                        #RegEx to generate an unexpanded string to use for correcting
                        $ValueRegEx = '(^(?!\u0022).*\.[Ee][Xx][Ee](?<!\u0022))(.*$)'
                        #Get the value without expanding the environmental names
                        $Value = $ParentKey.GetValue($Match, $Null, [Microsoft.Win32.RegistryValueOptions]::DoNotExpandEnvironmentNames)
                        $Value -match $ValueRegEx
                    }
                    #Uses the matches from the RegEx to build a new entry encapsulating the exe path with double quotes
                    $Correction = "$([char]34)$($Matches[1])$([char]34)$($Matches[2])"
                    #Attempt to correct the entry
                    Try { $ParentKey.SetValue("$Match", "$Correction", [Microsoft.Win32.RegistryValueKind]::$RegType) }
                    Catch { Write-Debug "Unable to write to $ParentKey" }
                    #Add a hashtable containing details of corrected key to ArrayList
                    $Values.Add((New-Object PSObject -Property @{
                    "Name" = $Match
                    "Type" = $RegType
                    "Value" = $Value
                    "Correction" = $Correction
                    "ParentKey" = "HKEY_LOCAL_MACHINE\$RegKey"
                    })) | Out-Null
                }
            }
        }
        $ParentKey.Close()
    }
    $Registry.Close()
    $Values | Select-Object ParentKey,Value,Correction,Name,Type
    if ($Values.Count -eq 0) {
        Write-Host "None Found"
    }
}

function ImageFileExec {
    # Check for Debugger - HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
    $keyPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options"
    $subkeys = Get-ChildItem -Path $keyPath
    
    foreach ($subkey in $subkeys) {
        $subkeyName = $subkey.PSChildName
        $item = (Get-ItemProperty -Path "$keyPath\$subkeyName" -ErrorAction SilentlyContinue)
        $GlobalFlag = $item.GlobalFlag
        $debuggerValue = $item.Debugger
        if ($debuggerValue) {
            Write-Host "Debugger found in $subkeyName with value $debuggerValue | $keyPath\$subkeyName" -ForegroundColor Red
        }
        if ($GlobalFlag) {
            Write-Host "Global Flag is set for $subkeyName | Check HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit" -ForegroundColor Red
        }
    }
}

function FailureCommand {
    # Check for Debugger - HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
    $keyPath = "HKLM:\SYSTEM\CurrentControlSet\Services"
    $subkeys = Get-ChildItem -Path $keyPath
    
    foreach ($subkey in $subkeys) {
        $subkeyName = $subkey.PSChildName
        $debuggerValue = (Get-ItemProperty -Path "$keyPath\$subkeyName" -ErrorAction SilentlyContinue).FailureCommand
        if ($debuggerValue) {
            Write-Host "FailureCommand found in $subkeyName with value $debuggerValue | $keyPath\$subkeyName" -ForegroundColor Red
        }
    }
}

function SecuritySupportProvider {
    $SecurityPackages = (GetRegistryKeyValue "HKLM:\system\currentcontrolset\control\lsa\Security Packages")

    if ($SecurityPackages -ne '""') {
        Write-Host "Security Packages: " $SecurityPackages -ForegroundColor Red
    } else { Write-Host "Security Packages: " $SecurityPackages }
    
}

function appInitDLLs {
    $AppInit1 = (GetRegistryKeyValue "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs")
    $AppInit2 = (GetRegistryKeyValue "HKLM:\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs")

    if ($AppInit1 -ne "") {
        Write-Host "App Init 1: " $AppInit1 -ForegroundColor Red
    } else { Write-Host "App Init 1: " $AppInit1 }

    if ($AppInit2 -ne "") {
        Write-Host "App Init 2: " $AppInit2 -ForegroundColor Red
    } else { Write-Host "App Init 2: " $AppInit2 }

}

function Netsh {
    $defaultConfig = @{
        "2" = "ifmon.dll"
        "4" = "rasmontr.dll"
        "authfwcfg" = "authfwcfg.dll"
        "dhcpclient" = "dhcpcmonitor.dll"
        "dot3cfg" = "dot3cfg.dll"
        "fwcfg" = "fwcfg.dll"
        "hnetmon" = "hnetmon.dll"
        "netiohlp" = "netiohlp.dll"
        "nettrace" = "nettrace.dll"
        "nshhttp" = "nshhttp.dll"
        "nshipsec" = "nshipsec.dll"
        "nshwfp" = "nshwfp.dll"
        "p2pnetsh" = "p2pnetsh.dll"
        "peerdistsh" = "peerdistsh.dll"
        "rpc" = "rpcnsh.dll"
        "WcnNetsh" = "WcnNetsh.dll"
        "whhelper" = "whhelper.dll"
        "wlancfg" = "wlancfg.dll"
        "wshelper" = "wshelper.dll"
        "wwancfg" = "wwancfg.dll"
        "PSPath" = "Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh"
        "PSParentPath" = "Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft"
        "PSChildName" = "NetSh"
    }
    
    $currentConfig = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\NetSh"
    
    foreach ($property in $currentConfig.PsObject.Properties) {
        $currentValue = $property.Value
        $defaultValue = $defaultConfig[$property.Name]
    
        if($currentValue -ne $defaultValue) {
            if($property.Name -ne "PSDrive" -and $property.Name -ne "PSProvider"){
                Write-Host -ForegroundColor Red -NoNewline "Difference found: Property: $($property.Name) Current Value: $currentValue Default Value: $defaultValue"
                Write-Host ""
           }
        }
    }    
}

function powershellProfiles {
    $CommonProfilePaths = @(
        "$Home\Documents\WindowsPowerShell\Profile.ps1"
        "$Home\Documents\Profile.ps1"
        "$PsHome\Microsoft.PowerShell_profile.ps1"
        "$PsHome\Profile.ps1"
        "$Home\Documents\WindowsPowerShell\Microsoft.P owerShellISE_profile.ps1"
        "$PsHome\Microsoft.PowerShellISE_profile.ps1"
    )

    foreach ($ProfilePath in $CommonProfilePaths) {
        if (Test-Path -Path $ProfilePath) {
            Write-Host "$ProfilePath exists." -ForegroundColor Red
        }
    }
}

function scrnsaver { 
    $scrnsaver = GetRegistryKeyValue "HKCU:\Control Panel\Desktop\SCRNSAVE.EXE"
    if($null -ne $scrnsaver) {
        Write-Host "SCRNSAVE: " $scrnsaver -ForegroundColor Red
    } else { Write-Host "SCRNSAVE: " $scrnsaver }
}

function ridHijacking {
    Write-Host "Administrator RID Users" -ForegroundColor Green
    $accounts = Get-WmiObject -Class Win32_UserAccount 
    foreach ($account in $accounts) {
        if($account.SID -like "*500*") {
            Write-Host ($account | Select-Object Name,SID) -ForegroundColor Red
        }
    }
}

Export-ModuleMember -Function * -Alias *